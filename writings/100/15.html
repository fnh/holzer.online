<meta name="category" content="100">
<section>
<h1>
Fifteen
</h1>

<p>
I've recently re-read Dan Ingalls article about the <a href="https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html">Design Principles Behind Smalltalk</a>. This text was in many subtle ways deeply influential on my thinking about software design. It starts of with describing the aspiration of the Smalltalk group at Xerox PARC as <q>to provide computer support for the creative spirit in everyone</q>, leading as a corollary to the principle of personal mastery that a system, which is to support that goal, <q>must be entirely comprehensible to a single individual</q>.
</p>

<p>
Now, fast forward fourty-odd years and contrast these noble aims with the mess that is basically all of modern computing (and software engineering as part of it). A column by George Fairbanks, that I also recently came across, reflects on <a href="https://www.georgefairbanks.com/ieee-software-v36-n1-jan-2019-intellectual-control">Intellectual Control</a>, and more specifically the loss of it and its (in my eyes lesser) replacement, statistical control through testing. Does he see ways out of the hole we've dug ourself into?
</p>

<blockquote>
There are several techniques commonly used to simplify software designs. If you see these, they are signs that the authors have intellectual control: separation of the problem and solution concerns, explicit data structure invariants, operations with clear contracts, minimization of the state space, attention to failure conditions, and a suitable architecture.
</blockquote>

<p>
Rich Hickey gave a well-received talk at the Strangeloop conference on <a href="https://www.youtube.com/watch?v=F87PtAoJNtg">Simple made easy</a>, but in the more that a dozen years that have passed since then, not too much in that direction happened. John Ousterhouts <a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">Philosopy of Software design</a> has many great pointers for a start, but could use a bit of companion literature. I hope Greg Wilson follows through with his idea of writing a book on <a href="https://third-bit.com/2024/06/14/human-scale-software/">Human-scale software</a>.
</p>

<p>
So, to formulate it as a big question looking for answers: how can to software systems be built so that you can keep intellectual control over them and potentially facilitate personal mastery over them for their users?
</p>

<p>
As I have about three decades of my professional life before me, so I should probably try to contribute a pieces or two to that puzzle.
</p>

<time datetime="2024-06-27 13:00">Thursday, the 27th of June 2024</time>

</section>

